# 散列表
散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性.
我们通过散列函数把元素的键值映射为下标， 然后将数据存储在数组中对应下标的位置.

## 散列函数
hash(key) = value: key表示元素的键值， value 表示经过hash()计算得到的散列值. 该公式描述了key到value的映射.

散列函数设计的基本要求：
1. 散列函数计算得到的散列值是一个非负整数
2. 如果 key1 = key2， 那 hash(key1) == hash(key2)
3. 如果 key1 ≠ key2， 那 hash(key1) ≠ hash(key2)

### 散列函数冲突
hash函数的规则3的实际情况是即便像业界著名的MD5、 SHA等哈希算法， 也无法完全避免这种散列冲突. 即便能找到完美的无冲突的散列函数， 付出的时间成本、 计算成本也是很大的， 所以针对散列冲突问题， 我们需要通过其他途径来解决.

我们常用的散列冲突解决方法有两类， 开放寻址法(open addressing) 和链表法(chaining).

#### 开放寻址法
开放寻址法的核心思想是， 如果出现了散列冲突， 我们就**重新探测一个空闲位置将其插入**.

常用线性探测（ Linear Probing）来重新探测新的位置.

在散列表中查找元素的过程有点儿类似插入过程. 我们通过散列函数求出要查找元素的键值对应的
散列值， 然后比较数组中下标为散列值的元素和要查找的元素, 如果相等， 则说明就是我们要找的
元素； 否则就顺序往后依次查找, 如果遍历到数组中的空闲位置， 还没有找到， 就说明要查找的元
素并没有在散列表中.

删除的元素时， 将其特殊标记为 deleted(避免空洞, 导致本来存在的数据， 会被认定为不存在). 当线性探测查找的时候， 遇到标记为 deleted 的空
间， 并不是停下来， 而是继续往下探测.

线性探测法其实存在很大问题。 当散列表中插入的数据越来越多时， 散列冲突发生的可能性就会越来越大， 空闲位置会越来越少， 线性探测的时间就会越来越久.

对于开放寻址冲突解决方法， 除了线性探测方法之外， 还有另外两种比较经典的探测方法， 二次探
测（ Quadratic probing） 和双重散列（ Double hashing）.

所谓二次探测， 跟线性探测很像， 线性探测每次探测的步长是 1， 那它探测的下标序列就是
hash(key)+0， hash(key)+1， hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”， 也就
是说， 它探测的下标序列就是 hash(key)+0， hash(key)+1^2， hash(key)+2^2……

所谓双重散列， 意思就是要使用一组散列函数hash1(key)， hash2(key)， hash3(key)……我们先用第一个散列函数， 如果计算得到的存储位置已经被
占用， 再用第二个散列函数， 依次类推， 直到找到空闲的存储位置.

> 一般情况下， 我们会尽可能保证散列表中有一定比例的空闲槽位。 我们用装载因子（ load factor = 填入表中的元素个数 / 散列表的长度） 来表示空位的多少.

#### 链表法
链表法是一种更加常用的散列冲突解决办法.

## FAQ
1. Word 文档中单词拼写检查功能是如何实现的
常用的英文单词有 20 万个左右， 假设单词的平均长度是 10 个字母， 平均一个单词占用 10 个字节
的内存空间， 那 20 万英文单词大约占 2MB 的存储空间， 就算放大 10 倍也就是 20MB. 对于现在
的计算机来说， 这个大小完全可以放在内存里面。 所以我们可以用散列表来存储整个英文单词词
典.