# 散列表
散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性.
我们通过散列函数把元素的键值映射为下标， 然后将数据存储在数组中对应下标的位置.

> map与set区别: map有kv, 而set仅有key.

> hashMap与TreeMap区别: hashMap查找是O(1)但无序, TreeMap查找是tree的复杂度但有序.

## 散列函数
hash(key) = value: key表示元素的键值， value(通常是一个无符号的整数) 表示经过hash()计算得到的散列值. 该公式描述了key到value的映射.

散列函数设计的基本要求：
1. 散列函数计算得到的散列值是一个非负整数
2. 如果 key1 = key2， 那 hash(key1) == hash(key2)
3. 如果 key1 ≠ key2， 那 hash(key1) ≠ hash(key2)

### 散列函数冲突
hash函数的规则3的实际情况是即便像业界著名的MD5、 SHA等哈希算法， 也无法完全避免这种散列冲突. 即便能找到完美的无冲突的散列函数， 付出的时间成本、 计算成本也是很大的， 所以针对散列冲突问题， 我们需要通过其他途径来解决.

我们常用的散列冲突解决方法有两类， 开放寻址法(open addressing) 和链表法(chaining).

> 链表法处理哈希冲突非常直观, 很容易理解和撰写代码, 但缺点是哈希桶和冲突链使用了不同的内存, 对缓存不友好.

### 散列表扩容方法
双散列法

插入: 将新数据插入新散列表中， 并且从老的散列表中拿出一个数据放入到新散列表. 重复该过程, 这样没有了集中的一次性数据搬移， 插入操作就都变得很快了
查询: 为了兼容了新、 老散列表中的数据， 我们先从新散列表中查找， 如果没有找到， 再去老的散列表中查找.

#### 开放寻址法
开放寻址法的核心思想是， 如果出现了散列冲突， 我们就**重新探测一个空闲位置将其插入**.

常用线性探测（ Linear Probing）来重新探测新的位置.

在散列表中查找元素的过程有点儿类似插入过程. 我们通过散列函数求出要查找元素的键值对应的
散列值， 然后比较数组中下标为散列值的元素和要查找的元素, 如果相等， 则说明就是我们要找的
元素； 否则就顺序往后依次查找, 如果遍历到数组中的空闲位置， 还没有找到， 就说明要查找的元
素并没有在散列表中.

删除的元素时， 将其特殊标记为 deleted(避免空洞, 导致本来存在的数据， 会被认定为不存在). 当线性探测查找的时候， 遇到标记为 deleted 的空
间， 并不是停下来， 而是继续往下探测.

线性探测法其实存在很大问题。 当散列表中插入的数据越来越多时， 散列冲突发生的可能性就会越来越大， 空闲位置会越来越少， 线性探测的时间就会越来越久.

对于开放寻址冲突解决方法， 除了线性探测方法之外， 还有另外两种比较经典的探测方法， 二次探
测（ Quadratic probing） 和双重散列（ Double hashing）.

所谓二次探测， 跟线性探测很像， 线性探测每次探测的步长是 1， 那它探测的下标序列就是
hash(key)+0， hash(key)+1， hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”， 也就
是说， 它探测的下标序列就是 hash(key)+0， hash(key)+1^2， hash(key)+2^2……

所谓双重散列， 意思就是要使用一组散列函数hash1(key)， hash2(key)， hash3(key)……我们先用第一个散列函数， 如果计算得到的存储位置已经被
占用， 再用第二个散列函数， 依次类推， 直到找到空闲的存储位置.

> 一般情况下， 我们会尽可能保证散列表中有一定比例的空闲槽位。 我们用装载因子（ load factor = 填入表中的元素个数 / 散列表的长度） 来表示空位的多少.
> 当数据量比较小、 装载因子小的时候， 适合采用开放寻址法.

优点: 开放寻址法不像链表法， 需要拉很多链表。 散列表中的数据都存储在数组中， 可以有效地利用 CPU缓存加快查询速度
缺点: 用开放寻址法解决冲突的散列表， 删除数据的时候比较麻烦， 需要特殊标记已经删除掉的数据. 而且， 在开放寻址法中， 所有的数据都存储在一个数组中， 比起链表法来说， 冲突
的代价更高. 所以， 使用开放寻址法解决冲突的散列表， 装载因子的上限不能太大. 这也导致这种方法比链表法更浪费内存空间.


#### 链表法
链表法是一种更加常用的散列冲突解决办法.

实际上对链表法稍加改造， 可以实现一个更加高效的散列表. 那就是， 我们将链表法中的链表改造为其他高效的动态数据结构， 比如跳表、 红黑树.

优点: 链表法对内存的利用率比开放寻址法要高, 且比较适合存储大对象、 大数据量的散列表， 而且， 比起开放寻址法， 它更加灵活， 支持更多的优化策略， 比如用红黑树代替链表

#### 再哈希法

## 一致性哈希

## FAQ
1. Word 文档中单词拼写检查功能是如何实现的
常用的英文单词有 20 万个左右， 假设单词的平均长度是 10 个字母， 平均一个单词占用 10 个字节
的内存空间， 那 20 万英文单词大约占 2MB 的存储空间， 就算放大 10 倍也就是 20MB. 对于现在
的计算机来说， 这个大小完全可以放在内存里面。 所以我们可以用散列表来存储整个英文单词词典.
