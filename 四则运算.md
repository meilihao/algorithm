# 四则运算
人能直接计算`A+B*C`, 但机器不能, 因为它不知道运算符优先级.

那如何让计算机知道顺序呢: 使用完成括号表达式即对每个运算符都使用一对括号, 比如`(A+(B*C))`. 现在知道了执行顺序, 完成括号表达式是一个中缀表达式(运算符在被操作数的中间), 将操作符和操作数混在了一起, 这种模式不利于计算机运算, 那么将它俩分开:
- 前缀表达式: 所有运算符在处理的两个操作数之前
- 后缀表达式: 所有运算符在处理的两个操作数之后

前中后缀表达式:
|中缀表达式 |前缀表达式| 后缀表达式|
|A + B |+ A B |A B +|
|A + B * C | + A * B C |A B C * +|
|(A + B) * C |* + A B C |A B + C *|
|A + B - C |- + A B C |A B + C -|
|A * B + C| + * A B C |A B * C +|
|A * B / C |/ * A B C| A B * C /|

复杂的前中后缀表达式:
|中缀表达式 |前缀表达式| 后缀表达式|
|A + B * C - D |- + A * B C D |A B C * + D -|
|A * B - C / D |- * A B / C D |A B * C D / -|
|A + B + C + D |+ + + A B C D |A B + C + D +|
|(A + B) * (C - D)| * + A B - C D| A B + C D - *|

## 中缀转前后表达式
ref:
- [算术表达式：前缀表达式、中缀表达式、后缀表达式相互转换](https://blog.51cto.com/u_15349906/3715870)

中缀表达式`a + b * c - ( d + e )`, 先按照运算符的优先级对所有的运算符加括号变成完全括号表达式: `( ( a + ( b * c ) ) - ( d + e ) )`,  在进行后续转化:
- 转前缀表达式：

    1. 将运算符移动到对应括号之前：`- ( + ( a * ( b c ) ) + ( d e ) )`
    1. 去掉括号：`- + a * b c + d e`
    1. 转换完成
- 中缀表达式转后缀表达式：

    1. 将运算符移动到对应括号之后：`( ( a ( b c ) * ) + ( d e ) + ) -`
    2. 去掉括号：`a b c * + d e + -`
    3. 转换完成

## 前后缀表达式计算
前缀表达式`+ A * B C`还是没法计算, 需要颠倒执行顺序, 而栈有这个功能. 因此可采用两个栈, 一个保存操作符, 一个保存操作数. 此时先将操作符号出栈，然后将两个操作数出栈，此时用操作符计算这两个操作数，结果再入栈. 接着再重复这个计算步骤，直到操作符号栈空，此时弹出操作数栈顶数据，这个值就是整个表达式的计算结果.

而后缀表达式`A B C * +`只需要使用一个栈. 先将 A B C 入栈，接着发现 * 号，弹出两个操作数 B C，计算得到结果 BC，再将其入栈，接着遇到 + 号，弹出两个操作数 A 和 BC，计算得到 A + BC.

可见不论前缀还是后缀表达式，都能用栈快速地计算出来.

然而，用计算机得到完全括号表达式本身就很困难，而且移动字符再删除字符涉及修改字符串，所以这种方法还不够通用.

如果不考虑操作符, 在中缀转前后缀表达式中可以看到操作数顺序不变, 因此仅考虑操作符即可. 因为操作符有优先级，往往会反转顺序。反转顺序是栈的特点，所以可以用栈来保存操符。

当从左到右扫描中缀表达式时，用栈来保留运算符，栈顶将始终是最近保存的运算符。每当读取到新的运算符时，需要将其与在栈上的运算符（如果有的话）比较优先级并决定是否弹出.

中缀转后缀表达式的伪代码是:
1. 创建一个名为 op_stack 的空栈以保存运算符, 给输出创建一个空列表 postfix
2. 通过使用字符串方法拆分将输入的中缀字符串转换为标记列表 src_str
3. 从左到右扫描src_str

    - 如果标记是操作数，将其附加到输出列表的末尾
    - 如果标记是左括号，将其压到 op_stack 上
    - 如果标记是右括号，则弹出 op_stack，直到删除相应左括号，将运算符加入 postfix
    - 如果标记是运算符`+ - * /`, 先弹出 op_stack 中更高或相等优先级的运算符到 postfix, 再压入 op_stack
4. 当输入处理完后，检查 op_stack，仍在栈上的运算符都可弹出到 postfix
