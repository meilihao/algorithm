# 复杂度
复杂度分析是整个算法学习的精髓， 通过它可以客观地度量算法效率. 只要掌握了它， 数据结构和算法的内容基本上就掌握了一半.

复杂度分:
- 时间复杂度, 常用.
- 空间复杂度, 不常用, 硬件普遍廉价.

实际判断算法优劣时, 优先考虑时间复杂度, 毕竟当前机器的内存都够大

### 事后统计法
通过统计、 监控， 也能得到算法执行的时间和占用的内存, 缺点:
1. 非常依赖测试环境, 比如硬件.
1. 受数据规模影响很大

## 大O表示法
所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比.

公式:
```
T(n) = O(f(n))
```
n 表示数据规模的大小； f(n) 表示每行代码执行的次数总和, O表示代码的执行时间 T(n) 与 f(n) 表达式成正比.

大O时间复杂度实际上并不具体表示代码真正的执行时间， 而是表示**代码执行时间随数据规模增长的变化趋势**.

因为公式中的**低阶、 常量、 系数三部分并不左右增长趋势**， 所以都可以忽略, 因此我们只需要记录一个**最大量级**就可以了.

在一般情况下（n > 10）, 存在 O(2^n) > O(n^3) > O(n^2) > O(nlogn) > O(n) > O(logn) > O(1)

### 如何分析一段代码的时间复杂度
1. 只关注循环执行次数最多的一段代码
1. 加法法则： 总复杂度等于量级最大的那段代码的复杂度
1. 乘法法则： 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 复杂度量级
1. 多项式量级: O(1),O(logN),O(n),O(N*logN),O(n^x)
1. 非多项式量级: O(2^n) 和 O(n!).

当数据规模 n 越来越大时， 非多项式量级算法的执行时间会急剧增加， 求解问题的执行时间会无限
增长. 所以， 非多项式时间复杂度的算法其实是非常低效的算法.

![](/misc/img/141025088894028.png)

## 复杂度分析
引入原因: 同一段代码在不同情况下时间复杂度也会出现量级差异， 为了更全面， 更准确的描述代码的时间复杂度.

### 最好情况时间复杂度（ best case timecomplexity） : 代码在最理想情况下执行的时间复杂度
### 最坏情况时间复杂度（ worst case time complexity） : 代码在最坏情况下执行的时间复杂度
### 平均情况时间复杂度（ average case time complexity） : 结合概率论, 用代码在所有情况下执行的次数的加权平均值表示
### 均摊时间复杂度（ amortized time complexity） : 在代码执行的所有复杂度情况中绝大部分是低级别的复杂度， 个别情况是高级别复杂度且发生具有时序关系时， 可以将个别高级别复杂度均摊到低级别复杂度上。 在能够应用均摊时间复杂度分析的场合， 一般均摊时间复杂度就等于最好情况时间复杂度
