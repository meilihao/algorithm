# 二叉树
在图论中，树(Tree）是一种无向图（undirected graph），其中任意两个顶点间存在唯一一条路径. 即只要没有回路的连通图就是树.

树的高度: 根节点的高度
节点的高度: 节点到叶子节点的**最长路径**(边数)
节点的深度: **根节点**到这个节点所经历的边的个数
节点的层数: 节点的深度+1

> 高度 : 从下往上度量; 深度 : 从上往下度量.

## 二叉树
每个节点至多有两个“叉”， 也就是两个子节点， 分别是左子节点和右子节点.

叶子节点全都在最底层， 且除了叶子节点之外， 每个节点都有左右两个子节点， 这种二叉树就叫作**满二叉树**.
叶子节点都在最底下两层， 最后一层的叶子节点都靠左排列， 并且除了最后一层， 其他层的节点个数都要达到最大， 这种二叉树叫作**完全二叉树**.

### 存储方式
#### 基于指针的链式存储法
每个节点有三个字段， 其中一个存储数据， 另外两个是指向左右子节点的指针．

#### 基于数组的顺序存储法
如果节点 X 存储在数组中下标为 i 的位置， 下标为 2 * i 的位置存储的就是左子节点， 下标为 2 * i + 1 的位置存储的就是右子节点． 反过来， 下标为 i/2 的位置存储就是它的父节点．　通过这种方式， 我们只要知道根节点存储的位置（**一般情况下， 为了方便计算子节点， 根节点会存储在下标为 1 的位置**）．

一棵完全二叉树， 所以仅仅“浪费”了一个下标为 0 的存储位置。 如果是非完全二叉树， 其实会浪费比较多的数组存储空间.
>　堆其实就是一种完全二叉树， 最常用的存储方式就是数组

### 遍历
- 前序遍历(根->左->右): 对于树中的任意节点来说， 先打印这个节点， 然后再打印它的左子树， 最后打印它的右子树
- 中序遍历(左->根->右): 对于树中的任意节点来说， 先打印它的左子树， 然后再打印它本身， 最后打印它的右子树
- 后序遍历(左->右->根): 对于树中的任意节点来说， 先打印它的左子树， 然后再打印它的右子树， 最后打印这个节点本身

> 前中后序均指相对于根来说.
> 每个节点最多会被访问两次， 所以遍历操作的时间复杂度， 跟节点的个数 n 成正比， 也就是说二叉树遍历的时间复杂度是 O(n).

#### 递推公式
前序遍历的递推公式：preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)
中序遍历的递推公式：postOrder(r) = postOrder(r->left)->print r->postOrder(r->right)
后序遍历的递推公式：postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r

### 二叉查找树
二叉查找树要求， 在树中的任意一个节点， 其左子树中的每个节点的值， 都要小于这个节点的值， 而右子树节点的值都大于这个节点的值.

最大的特点就是， 支持动态数据集合的快速插入、 删除、 查找操作, 且时间复杂度也比较稳定， 是 O(logn).

### 红黑树
二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 logN 的情况，从而导致各个操作的效率下降.极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n). 要解决这个复杂度退化的问题，我们需要设计一种平衡二叉查找树，也就是红黑树.

> 平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1. 从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树.
> 平衡二叉查找树其实有很多，比如，Splay Tree（伸展树）、Treap（树堆）等，但是我们提到平衡二叉查找树，听到的基本都是红黑树, 为什么它们不是: 绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化.
> 红黑树是“近似平衡”的: 平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重

红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：
1. 根节点是黑色的
1. 每个叶子节点都是黑色的空节点，也就是说，叶子节点不存储数据
1. 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的
1. 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点

### 堆
堆是一种特殊的树, 满足两个要求:
1. 堆是一个完全二叉树
1. 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值

> 对于每个节点的值都大于等于子树中每个节点值的堆，我们叫作“大顶堆/最大堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作“小顶堆/最小堆”

## FAQ
1. 散列表的插入、 删除、 查找操作的时间复杂度可以做到常量级的 O(1)非常高效, 而二叉查找树在比较平衡的情况下， 插入、 删除、 查找操作时间复杂度才是 O(logn)， 相对散列表， 好像并没有什么优势， 那我们为什么还要用二叉查找树呢？
  1. 散列表中的数据是无序存储的， 如果要输出有序的数据， 需要先进行排序;而对于二叉查找树来说， 我们只需要中序遍历， 就可以在 O(n) 的时间复杂度内， 输出有序的数据序列.
  1. 散列表扩容耗时很多， 而且当遇到散列冲突时， 性能不稳定， 尽管二叉查找树的性能不稳定， 但是在工程中， 我们最常用的平衡二叉查找树的性能非常稳定， 时间复杂度稳定在 O(logn)
  1. 尽管散列表的查找等操作的时间复杂度是常量级的， 但因为哈希冲突的存在，这个常量不一定比 logn 小， 所以实际的查找速度可能不一定比 O(logn) 快。 加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高
  1. 散列表的构造比二叉查找树要复杂， 需要考虑的东西很多。 比如散列函数的设计、 冲突解决办法、 扩容、 缩容等。 平衡二叉查找树只需要考虑平衡性这一个问题， 而且这个问题的解决方案比较成熟、 固定
  1. 为了避免过多的散列冲突， 散列表装载因子不能太大， 特别是基于开放寻址法解决冲突的散列表， 不然会浪费一定的存储空间