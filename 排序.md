# 排序
![](/misc/img/sort.png)
![](/misc/img/1353292587_2279.png)
![](/misc/img/array_sorting_algorithms.png)

常见排序:
- O(n^2) : 冒泡, 插入, 选择
- O(NlogN) : 快排, 归并, 堆
- O(n) : 桶, 计数, 基数

> 原地排序算法: 特指空间复杂度是 O(1) 的排序算法
> 稳定性: 如果待排序的序列中存在值相等的元素， 经过排序之后， 相等元素之间原有的先后顺序不变
> 桶, 计数, 基数这些排序算法的时间复杂度是线性的， 所以我们把这类排序算法叫作线性排序（ Linear sort）, 且它们都是**非基于比较的排序算法， 都不涉及元素之间的比较操作**

原地排序: 冒泡, 插入, 选择, 快排, 堆
稳定: 冒泡, 插入, 计数, 桶(看桶里的排序方法), 基数

> 插入排序要比冒泡排序更受欢迎: 冒泡排序的数据交换要比插入排序的数据移动要复杂， 冒泡排序需要 3个赋值操作， 而插入排序只需要 1 个.
> **归并排序稳不稳定关键要看 merge()函数**， 也就是两个有序子数组合并成一个有序数组的那部分代码. **归并排序不是原地排序算法**
> 桶排序的核心思想是将要排序的数据分到几个有序的桶里， **每个桶里的数据再单独进行排序**
> 计数排序其实是桶排序的一种特殊情况. 把n个数据划分到 k 个桶. 每个桶内的数据值都是相同的， 省掉了桶内排序的时间. 计数排序只能给非负整数排序， 如果要排序的数据是其他类型的， 要将其在不改变相对大小的情况下， 转化为非负整数.

## 基数排序
按照每位来排序的排序算法要是稳定的， 否则这个实现思路就是不正确的: 因为如果是非稳定排序算法， 那最后一次排序只会考虑最高位的大小顺序， 完全不管后面位的大小关系， 那么低位的排序就完全没有意义了.

有时候要排序的数据并不都是等长的, 我们可以把所有的单词补齐到相同长度， 位数不够的可以在后面补“0”， 因为根据ASCII
值， 所有字母都大于“0”， 所以补“0”不会影响到原有的大小顺序.

## FAQ
1. 在实际开发中，为什么快速排序要比堆排序性能好
  1. 堆排序数据访问的方式没有快速排序友好: 对于快速排序来说，数据是顺序访问的, 而对于堆排序来说，数据是跳着访问的, 这样对CPU缓存是不友好的.
  1. 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序: 堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低.比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了
