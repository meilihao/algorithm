/*
926.中 将字符串翻转到单调递增

如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。

给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。

返回使 s 单调递增的最小翻转次数。

示例 1：

输入：s = "00110"
输出：1
解释：翻转最后一位得到 00111.
示例 2：

输入：s = "010110"
输出：2
解释：翻转得到 011111，或者是 000111。
示例 3：

输入：s = "00011000"
输出：2
解释：翻转得到 00000000。

提示：

1 <= s.length <= 105
s[i] 为 '0' 或 '1'
*/
package leetcode

import (
	"testing"
)

// 题意: 原字符串 => [0]{n}[1]{n}
func TestMinFlipsMonoIncr(t *testing.T) {

}

func minFlipsMonoIncr(s string) int {
	// dp0 存储以 '0' 结尾的单调递增子序列所需的最少翻转次数 = 当前处理到第 i 位，将 s[0:i] 转换为以 0 结尾的单调字符串 所需的最小翻转次数
	// dp1 存储以 '1' 结尾的单调递增子序列所需的最少翻转次数 = 当前处理到第 i 位，将 s[0:i] 转换为以 1 结尾的单调字符串 所需的最小翻转次数
	// 初始状态：空字符串，没有翻转，所以都为 0
	dp0, dp1 := 0, 0

	for _, c := range s {
		// s[0:i] + c :想要保持末尾是 0，那它必须是 '0'
		// s[0:i] +c : 末尾是 1 的话，前面可以是以 0 或 1 结尾的单调串，所以取 min(dp0, dp1)
		dp0New, dp1New := dp0, min(dp0, dp1)
		if c == '1' {
			// 要使当前字符最终为 '0' (dp0New)，必须翻转当前的 '1'
			dp0New++
			// 要使当前字符最终为 '1' (dp1New)，不需要翻转当前的 '1'
		} else { // 如果当前字符 c 是 '0'
			// 要使当前字符最终为 '0' (dp0New)，不需要翻转当前的 '0'
			// 要使当前字符最终为 '1' (dp1New)，必须翻转当前的 '0'
			dp1New++
		}
		dp0, dp1 = dp0New, dp1New
	}
	return min(dp0, dp1)
}
