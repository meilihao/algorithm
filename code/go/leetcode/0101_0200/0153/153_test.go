/*
153.中 寻找旋转排序数组中的最小值

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。


示例 1：

输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
示例 2：

输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
示例 3：

输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。


提示：

n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
nums 中的所有整数 互不相同
nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转
*/

package demo

import (
	"fmt"
	"testing"
)

/*
假设最小值的索引是p, p将数组分成了两部分, 每部分都是严格递增的数组, 且前半部的每个值都>后半部的每个值
*/
func TestFindMin(t *testing.T) {
	nums1 := []int{0, 1, 2, 3, 4, 5} // 旋转n次变回原数组
	nums2 := []int{3, 4, 5, 0, 1, 2}

	fmt.Println(findMin(nums1), findMin(nums1) == 0)
	fmt.Println(findMin(nums2), findMin(nums2) == 0)
}

func findMin(nums []int) int {
	l := 0
	r := len(nums) - 1

	for l < r { // 当 l == r 时，表示已找到, 循环结束，nums[l] 就是最小值
		mid := l + (r-l)/2
		//fmt.Println(l, r, mid)
		// nums[mid]与后半部的最大值比较
		if nums[mid] < nums[r] { // 因为every(前半)>every(后半) , 因此mid在后半部分, 又因为后半也有序, 因此nums[mid]是最小值右侧的元素或本身
			r = mid
		} else { // mid在前半部分, p肯定在mid后面
			l = mid + 1
		}
	}
	return nums[l]
}
