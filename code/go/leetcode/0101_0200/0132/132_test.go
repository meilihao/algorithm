/*
132.困 分割回文串 II

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。

返回符合要求的 最少分割次数 。

示例 1：

输入：s = "aab"
输出：1
解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
示例 2：

输入：s = "a"
输出：0
示例 3：

输入：s = "ab"
输出：1

提示：

1 <= s.length <= 2000
s 仅由小写英文字母组成
*/
package leetcode

import (
	"math"
	"testing"
)

func TestMinCut(t *testing.T) {

}

func minCut(s string) int {
	n := len(s)
	g := make([][]bool, n) // g[i][j] 表示子串 s[i...j] 是否为回文串
	for i := range g {
		g[i] = make([]bool, n)
		for j := range g[i] {
			// j<i即空串, j=x即单串
			// g[i+1][j-1] 默认为 true 的巧妙之处在于，它利用了 g 数组的初始化值来处理了最短的回文子串（空串和单字符）的情况，避免了在 for 循环内部写额外的 if 条件来处理这些边界
			g[i][j] = true // 初始设为 true 是为了方便处理 g[i+1][j-1] 在 j-1 < i+1 时的边界情况
		}
	}
	// 外层循环 i 从 n-1 递减到 0，内层循环 j 从 i+1 递增到 n-1, 这种顺序确保了当计算 g[i][j] 时，所需的 g[i+1][j-1] 已经计算完成
	// ???
	for i := n - 1; i >= 0; i-- {
		for j := i + 1; j < n; j++ {
			// g[i][j] 为回文的条件是：
			// 1. s[i] == s[j] (首尾字符相等)
			// 2. 且 s[i+1...j-1] 也是回文 (由 g[i+1][j-1] 表示)
			// 如果 j-1 < i+1 (即子串长度小于等于2)，g[i+1][j-1] 默认为 true，因为空串或单字符是回文

			// g[i][j] 依赖于 g[i+1][j-1], g[i+1][j-1] 所代表的子串，其起始索引更靠右，结束索引更靠左，并且总是比 s[i...j] 短
			// 通过 i 从大到小（从右向左）遍历，我们确保了当我们计算 g[i][j] 时，任何一个起始索引比 i 大的 g[i+1][...] 都已经计算完毕
			// 通过 j 从小到大（从左向右）遍历，我们确保了当我们计算 g[i][j] 时，任何一个结束索引比 j 小的 g[...][j-1] 也已经被涵盖在之前的计算中
			g[i][j] = s[i] == s[j] && g[i+1][j-1]
		}
	}

	f := make([]int, n) //f[i] 表示字符串 s 的前 i+1 个字符 s[0...i] 进行回文分割所需的最少分割次数
	for i := range f {
		// 如果 s[0...i] 本身就是回文串，那么不需要任何分割，次数为 0
		if g[0][i] {
			continue
		}
		f[i] = math.MaxInt64 // 如果不是回文子串，初始化为最大值

		// 尝试所有可能的分割点 j
		// s[0...i] 可以被分割成 s[0...j] 和 s[j+1...i]
		// 其中 s[j+1...i] 必须是回文串
		for j := 0; j < i; j++ {
			// 如果子串 s[j+1...i] 是回文串. 那么 f[i] 的一个可能值就是 f[j] + 1（f[j] 是分割 s[0...j] 的次数，+1 是指在 j 处的这次分割）
			// 为什么不用同时检查g[0][j] 也是回文: f[j] 的作用隐含前缀部分是回文的最优解
			if g[j+1][i] && f[j]+1 < f[i] {
				f[i] = f[j] + 1
			}
		}
	}
	return f[n-1]
}
