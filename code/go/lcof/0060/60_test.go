/*
LCR 185.中 统计结果概率

你选择掷出 num 个色子，请返回所有点数总和的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 num 个骰子所能掷出的点数集合中第 i 小的那个的概率。

示例 1：

输入：num = 3
输出：[0.00463,0.01389,0.02778,0.04630,0.06944,0.09722,0.11574,0.12500,0.12500,0.11574,0.09722,0.06944,0.04630,0.02778,0.01389,0.00463]
示例 2：

输入：num = 5
输出:[0.00013,0.00064,0.00193,0.00450,0.00900,0.01620,0.02636,0.03922,0.05401,0.06944,0.08372,0.09452,0.10031,0.10031,0.09452,0.08372,0.06944,0.05401,0.03922,0.02636,0.01620,0.00900,0.00450,0.00193,0.00064,0.00013]

提示：

1 <= num <= 11
*/
package main

import (
	"fmt"
	"testing"
)

func TestStatisticsProbability(t *testing.T) {
	n := 3
	fmt.Println(statisticsProbability(n))
}

func statisticsProbability(n int) []float64 {
	// dp[x][y] 数组的索引 y 并不直接代表实际的点数之和. 它是为了适应数组从 0 开始索引的特性而做的一个偏移
	dp := make([][]float64, n) // i=色子数量-1, j是对应点数和的index, 实际点数之和是 j + (i + 1) (找规律得到)
	for i := range dp {
		// 和的范围sum=`(i+1)*1`~`(i+1)*6`, len(sum)=((i+1)*6 - (i+1)*1) + 1 = (i+1)*6-i
		dp[i] = make([]float64, (i+1)*6-i) // 每轮点数和
	}
	for i := range dp[0] {
		dp[0][i] = float64(1) / float64(6)
	}
	for i := 1; i < len(dp); i++ {
		for j := range dp[i-1] { // 投掷 i 个骰子时所有可能的点数之和 j（即 dp[i-1] 中的索引）
			for k := range dp[0] { // 模拟投掷第 (i+1) 个骰子 = 在上一次点数和的基础再投掷一次
				// dp[i][j+k] = 使用 i+1 个骰子时，得到点数总和为 j+k 的概率
				// dp[i-1][j]) = 使用 i 个骰子时，得到某个点数总和 j 的概率
				// i 个骰子的实际和是 j + i =  j + ((i-1) + 1)
				// 第 (i+1) 个骰子的实际点数是 k + 1
				// (i+1) 个骰子的实际总和是 (j + i) + (k + 1) = (j + k) + (i + 1)
				// `+=`: 对于同一个目标总和 s = j+k，可能有多种不同的 (j,k) 组合能达成, 需要把所有可能的路径概率累加起来
				dp[i][j+k] += float64(dp[i-1][j]) * float64(dp[0][k])
			}
		}
	}
	return dp[n-1]
}
